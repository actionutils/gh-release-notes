import * as fs from "node:fs/promises";
import * as path from "node:path";
import yaml from "js-yaml";
import {
	convertGitHubToReleaseDrafter,
	isGitHubReleaseConfig,
} from "../github-config-converter";
import { logWarning } from "../logger";

export interface MigrateOptions {
	source?: string; // path to GitHub release.yml or release.yaml
	output?: string; // path or '-' for stdout
	force?: boolean;
}

export type MigrateResult =
	| { status: "printed"; content: string; warnings: string[] }
	| {
			status: "created" | "overwrote" | "up-to-date" | "nothing-to-migrate";
			path?: string;
			content?: string;
			warnings: string[];
	  };

async function fileExists(p: string): Promise<boolean> {
	try {
		await fs.access(p);
		return true;
	} catch {
		return false;
	}
}

function dumpYaml(obj: unknown): string {
  return (
    yaml.dump(obj, {
      indent: 2,
      lineWidth: -1,
      noRefs: true,
    }) + "\n"
  );
}

function headerComment(): string {
  const lines = [
    "# Release Drafterâ€“compatible configuration generated by gh-release-notes",
    "# gh-release-notes: https://github.com/actionutils/gh-release-notes",
    "# Release Drafter: https://github.com/release-drafter/release-drafter",
  ];
  return lines.join("\n") + "\n";
}

/**
 * Detect source file path per defaults.
 */
async function detectSourcePath(cwd: string): Promise<string | undefined> {
	const yml = path.join(cwd, ".github", "release.yml");
	const yamlPath = path.join(cwd, ".github", "release.yaml");
	if (await fileExists(yml)) return yml;
	if (await fileExists(yamlPath)) return yamlPath;
	return undefined;
}

/**
 * Migrate GitHub's .github/release.yml(.yaml) to release-drafter format.
 */
export async function migrateCommand(
	opts: MigrateOptions = {},
): Promise<MigrateResult> {
	const cwd = process.cwd();
	const source =
		(opts.source && opts.source.length > 0
			? path.resolve(opts.source)
			: await detectSourcePath(cwd)) ?? undefined;

	if (!source) {
		throw new Error(
			"No source release config found. Provide --source or add .github/release.yml(.yaml).",
		);
	}

	let raw: string;
	try {
		raw = await fs.readFile(source, "utf8");
	} catch {
		throw new Error(`Failed to read source file: ${source}`);
	}

	let parsed: unknown;
	try {
		parsed = yaml.load(raw);
	} catch {
		throw new Error(`Failed to parse YAML from source: ${source}`);
	}

	const warnings: string[] = [];

	// If it's clearly GitHub release.yml, convert; else treat as Release Drafter already.
	let rdConfig: unknown;
	if (isGitHubReleaseConfig(parsed)) {
		// Pre-scan for per-category excludes that cannot be mapped exactly
		const categories = parsed.changelog?.categories ?? [];
		for (const cat of categories ?? []) {
			if (cat?.exclude?.labels || cat?.exclude?.authors) {
				const msg = `Category "${cat.title}" has per-category excludes that are not supported by release-drafter. Using global exclusions and uncategorized behavior instead.`;
				warnings.push(msg);
			}
		}
		rdConfig = convertGitHubToReleaseDrafter(parsed);
	} else {
		// Already a release-drafter style config
		// If not explicitly asked to output to stdout, return nothing-to-migrate
		const output =
			opts.output && opts.output.length > 0 ? opts.output : undefined;
		if (!output) {
			return { status: "nothing-to-migrate", warnings };
		}
		// If asked to print to stdout, print normalized YAML of the original
		const yamlOut = headerComment() + dumpYaml(parsed ?? {});
		if (output === "-") {
			return { status: "printed", content: yamlOut, warnings };
		}
		// Otherwise, write to the given output path with safe semantics below
		rdConfig = parsed ?? {};
	}

	const output =
		opts.output && opts.output.length > 0
			? opts.output
			: ".github/release-drafter.yml";
  if (output === "-") {
    const content = headerComment() + dumpYaml(rdConfig);
    return { status: "printed", content, warnings };
  }

	const outPath = path.resolve(output);
	const parent = path.dirname(outPath);
	await fs.mkdir(parent, { recursive: true });

  const content = headerComment() + dumpYaml(rdConfig);

	try {
		const existing = await fs.readFile(outPath, "utf8");
		if (existing === content) {
			// Emit warnings to stderr for visibility, but still return
			for (const w of warnings) logWarning(w);
			return { status: "up-to-date", path: outPath, content, warnings };
		}
		if (!opts.force) {
			throw new Error(
				`Refusing to overwrite existing file without --force: ${outPath}`,
			);
		}
		await fs.writeFile(outPath, content, "utf8");
		for (const w of warnings) logWarning(w);
		return { status: "overwrote", path: outPath, content, warnings };
	} catch (e: unknown) {
		const err = e as NodeJS.ErrnoException;
		if (err && err.code === "ENOENT") {
			await fs.writeFile(outPath, content, "utf8");
			for (const w of warnings) logWarning(w);
			return { status: "created", path: outPath, content, warnings };
		}
		// Emit collected warnings before rethrowing for consistency
		for (const w of warnings) logWarning(w);
		throw e;
	}
}
